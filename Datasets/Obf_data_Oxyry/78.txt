""#line:1:"""Generate and work with PEP 425 Compatibility Tags."""
from __future__ import absolute_import #line:2:from __future__ import absolute_import
import distutils .util #line:4:import distutils.util
import logging #line:5:import logging
import platform #line:6:import platform
import re #line:7:import re
import sys #line:8:import sys
import sysconfig #line:9:import sysconfig
import warnings #line:10:import warnings
from collections import OrderedDict #line:11:from collections import OrderedDict
import pip ._internal .utils .glibc #line:13:import pip._internal.utils.glibc
from pip ._internal .utils .compat import get_extension_suffixes #line:14:from pip._internal.utils.compat import get_extension_suffixes
from pip ._internal .utils .typing import MYPY_CHECK_RUNNING #line:15:from pip._internal.utils.typing import MYPY_CHECK_RUNNING
if MYPY_CHECK_RUNNING :#line:17:if MYPY_CHECK_RUNNING:
    from typing import (Tuple ,Callable ,List ,Optional ,Union ,Dict )#line:20:)
    Pep425Tag =Tuple [str ,str ,str ]#line:22:Pep425Tag = Tuple[str, str, str]
logger =logging .getLogger (__name__ )#line:24:logger = logging.getLogger(__name__)
_O00OO0O00OOOOO0OO =re .compile (r'(.+)_(\d+)_(\d+)_(.+)')#line:26:_osx_arch_pat = re.compile(r'(.+)_(\d+)_(\d+)_(.+)')
def get_config_var (O0O0OOO00OOOO00OO ):#line:29:def get_config_var(var):
    try :#line:31:try:
        return sysconfig .get_config_var (O0O0OOO00OOOO00OO )#line:32:return sysconfig.get_config_var(var)
    except IOError as OO0O00O0000000O00 :#line:33:except IOError as e:  # Issue #1074
        warnings .warn ("{}".format (OO0O00O0000000O00 ),RuntimeWarning )#line:34:warnings.warn("{}".format(e), RuntimeWarning)
        return None #line:35:return None
def get_abbr_impl ():#line:38:def get_abbr_impl():
    ""#line:40:"""Return abbreviated implementation name."""
    if hasattr (sys ,'pypy_version_info'):#line:41:if hasattr(sys, 'pypy_version_info'):
        O00OO0O0O0OOO000O ='pp'#line:42:pyimpl = 'pp'
    elif sys .platform .startswith ('java'):#line:43:elif sys.platform.startswith('java'):
        O00OO0O0O0OOO000O ='jy'#line:44:pyimpl = 'jy'
    elif sys .platform =='cli':#line:45:elif sys.platform == 'cli':
        O00OO0O0O0OOO000O ='ip'#line:46:pyimpl = 'ip'
    else :#line:47:else:
        O00OO0O0O0OOO000O ='cp'#line:48:pyimpl = 'cp'
    return O00OO0O0O0OOO000O #line:49:return pyimpl
def get_impl_ver ():#line:52:def get_impl_ver():
    ""#line:54:"""Return implementation version."""
    O000O00O000OO0000 =get_config_var ("py_version_nodot")#line:55:impl_ver = get_config_var("py_version_nodot")
    if not O000O00O000OO0000 or get_abbr_impl ()=='pp':#line:56:if not impl_ver or get_abbr_impl() == 'pp':
        O000O00O000OO0000 =''.join (map (str ,get_impl_version_info ()))#line:57:impl_ver = ''.join(map(str, get_impl_version_info()))
    return O000O00O000OO0000 #line:58:return impl_ver
def get_impl_version_info ():#line:61:def get_impl_version_info():
    ""#line:64:version."""
    if get_abbr_impl ()=='pp':#line:65:if get_abbr_impl() == 'pp':
        return (sys .version_info [0 ],sys .pypy_version_info .major ,sys .pypy_version_info .minor )#line:70:sys.pypy_version_info.minor)  # type: ignore
    else :#line:71:else:
        return sys .version_info [0 ],sys .version_info [1 ]#line:72:return sys.version_info[0], sys.version_info[1]
def get_impl_tag ():#line:75:def get_impl_tag():
    ""#line:79:"""
    return "{}{}".format (get_abbr_impl (),get_impl_ver ())#line:80:return "{}{}".format(get_abbr_impl(), get_impl_ver())
def get_flag (O00OO0OOO0O0O0OO0 ,OOO000OOO0OOO0O0O ,expected =True ,warn =True ):#line:83:def get_flag(var, fallback, expected=True, warn=True):
    ""#line:86:var is unset or unavailable."""
    O00000OO0OO0OO0OO =get_config_var (O00OO0OOO0O0O0OO0 )#line:87:val = get_config_var(var)
    if O00000OO0OO0OO0OO is None :#line:88:if val is None:
        if warn :#line:89:if warn:
            logger .debug ("Config variable '%s' is unset, Python ABI tag may " "be incorrect",O00OO0OOO0O0O0OO0 )#line:91:"be incorrect", var)
        return OOO000OOO0OOO0O0O ()#line:92:return fallback()
    return O00000OO0OO0OO0OO ==expected #line:93:return val == expected
def get_abi_tag ():#line:96:def get_abi_tag():
    ""#line:99:(CPython 2, PyPy)."""
    OOO0OOO0OO000OO00 =get_config_var ('SOABI')#line:100:soabi = get_config_var('SOABI')
    O0O0OO0O0O0O0OOOO =get_abbr_impl ()#line:101:impl = get_abbr_impl()
    if not OOO0OOO0OO000OO00 and O0O0OO0O0O0O0OOOO in {'cp','pp'}and hasattr (sys ,'maxunicode'):#line:102:if not soabi and impl in {'cp', 'pp'} and hasattr(sys, 'maxunicode'):
        O0000O00O0O0O0O0O =''#line:103:d = ''
        OOO0O0O0O000OO00O =''#line:104:m = ''
        OO00O00000OOOOOO0 =''#line:105:u = ''
        if get_flag ('Py_DEBUG',lambda :hasattr (sys ,'gettotalrefcount'),warn =(O0O0OO0O0O0O0OOOO =='cp')):#line:108:warn=(impl == 'cp')):
            O0000O00O0O0O0O0O ='d'#line:109:d = 'd'
        if get_flag ('WITH_PYMALLOC',lambda :O0O0OO0O0O0O0OOOO =='cp',warn =(O0O0OO0O0O0O0OOOO =='cp')):#line:112:warn=(impl == 'cp')):
            OOO0O0O0O000OO00O ='m'#line:113:m = 'm'
        if get_flag ('Py_UNICODE_SIZE',lambda :sys .maxunicode ==0x10ffff ,expected =4 ,warn =(O0O0OO0O0O0O0OOOO =='cp'and sys .version_info <(3 ,3 )))and sys .version_info <(3 ,3 ):#line:119:and sys.version_info < (3, 3):
            OO00O00000OOOOOO0 ='u'#line:120:u = 'u'
        OOO0OO00OOOO0OO0O ='%s%s%s%s%s'%(O0O0OO0O0O0O0OOOO ,get_impl_ver (),O0000O00O0O0O0O0O ,OOO0O0O0O000OO00O ,OO00O00000OOOOOO0 )#line:121:abi = '%s%s%s%s%s' % (impl, get_impl_ver(), d, m, u)
    elif OOO0OOO0OO000OO00 and OOO0OOO0OO000OO00 .startswith ('cpython-'):#line:122:elif soabi and soabi.startswith('cpython-'):
        OOO0OO00OOOO0OO0O ='cp'+OOO0OOO0OO000OO00 .split ('-')[1 ]#line:123:abi = 'cp' + soabi.split('-')[1]
    elif OOO0OOO0OO000OO00 :#line:124:elif soabi:
        OOO0OO00OOOO0OO0O =OOO0OOO0OO000OO00 .replace ('.','_').replace ('-','_')#line:125:abi = soabi.replace('.', '_').replace('-', '_')
    else :#line:126:else:
        OOO0OO00OOOO0OO0O =None #line:127:abi = None
    return OOO0OO00OOOO0OO0O #line:128:return abi
def _O0O0O0OO0OO0OOO0O ():#line:131:def _is_running_32bit():
    return sys .maxsize ==2147483647 #line:133:return sys.maxsize == 2147483647
def get_platform ():#line:136:def get_platform():
    ""#line:138:"""Return our platform name 'win32', 'linux_x86_64'"""
    if sys .platform =='darwin':#line:139:if sys.platform == 'darwin':
        OO0O00O00OOOOOOO0 ,_O00000OO000000O00 ,OO0000OO000O00O00 =platform .mac_ver ()#line:143:release, _, machine = platform.mac_ver()
        OO00O00OOOO0OOOO0 =OO0O00O00OOOOOOO0 .split ('.')#line:144:split_ver = release.split('.')
        if OO0000OO000O00O00 =="x86_64"and _O0O0O0OO0OO0OOO0O ():#line:146:if machine == "x86_64" and _is_running_32bit():
            OO0000OO000O00O00 ="i386"#line:147:machine = "i386"
        elif OO0000OO000O00O00 =="ppc64"and _O0O0O0OO0OO0OOO0O ():#line:148:elif machine == "ppc64" and _is_running_32bit():
            OO0000OO000O00O00 ="ppc"#line:149:machine = "ppc"
        return 'macosx_{}_{}_{}'.format (OO00O00OOOO0OOOO0 [0 ],OO00O00OOOO0OOOO0 [1 ],OO0000OO000O00O00 )#line:151:return 'macosx_{}_{}_{}'.format(split_ver[0], split_ver[1], machine)
    O0O00O0OOOOOO0OO0 =distutils .util .get_platform ().replace ('.','_').replace ('-','_')#line:154:result = distutils.util.get_platform().replace('.', '_').replace('-', '_')
    if O0O00O0OOOOOO0OO0 =="linux_x86_64"and _O0O0O0OO0OO0OOO0O ():#line:155:if result == "linux_x86_64" and _is_running_32bit():
        O0O00O0OOOOOO0OO0 ="linux_i686"#line:158:result = "linux_i686"
    return O0O00O0OOOOOO0OO0 #line:160:return result
def is_manylinux1_compatible ():#line:163:def is_manylinux1_compatible():
    if get_platform ()not in {"linux_x86_64","linux_i686"}:#line:166:if get_platform() not in {"linux_x86_64", "linux_i686"}:
        return False #line:167:return False
    try :#line:170:try:
        import _manylinux #line:171:import _manylinux
        return bool (_manylinux .manylinux1_compatible )#line:172:return bool(_manylinux.manylinux1_compatible)
    except (ImportError ,AttributeError ):#line:173:except (ImportError, AttributeError):
        pass #line:175:pass
    return pip ._internal .utils .glibc .have_compatible_glibc (2 ,5 )#line:178:return pip._internal.utils.glibc.have_compatible_glibc(2, 5)
def is_manylinux2010_compatible ():#line:181:def is_manylinux2010_compatible():
    if get_platform ()not in {"linux_x86_64","linux_i686"}:#line:184:if get_platform() not in {"linux_x86_64", "linux_i686"}:
        return False #line:185:return False
    try :#line:188:try:
        import _manylinux #line:189:import _manylinux
        return bool (_manylinux .manylinux2010_compatible )#line:190:return bool(_manylinux.manylinux2010_compatible)
    except (ImportError ,AttributeError ):#line:191:except (ImportError, AttributeError):
        pass #line:193:pass
    return pip ._internal .utils .glibc .have_compatible_glibc (2 ,12 )#line:196:return pip._internal.utils.glibc.have_compatible_glibc(2, 12)
def get_darwin_arches (O0OO0OOOOOOOOOO0O ,O000OO0O0000O0OO0 ,O0O00OOO00O0O0O0O ):#line:199:def get_darwin_arches(major, minor, machine):
    ""#line:203:"""
    O0OO000O000OOOO00 =[]#line:204:arches = []
    def _OOO0OOO0O0OO0O000 (O000000O0OOOO00OO ,OO0000OOOO000000O ,O00O0O0O0OOO0O0O0 ):#line:206:def _supports_arch(major, minor, arch):
        if O00O0O0O0OOO0O0O0 =='ppc':#line:229:if arch == 'ppc':
            return (O000000O0OOOO00OO ,OO0000OOOO000000O )<=(10 ,5 )#line:230:return (major, minor) <= (10, 5)
        if O00O0O0O0OOO0O0O0 =='ppc64':#line:231:if arch == 'ppc64':
            return (O000000O0OOOO00OO ,OO0000OOOO000000O )==(10 ,5 )#line:232:return (major, minor) == (10, 5)
        if O00O0O0O0OOO0O0O0 =='i386':#line:233:if arch == 'i386':
            return (O000000O0OOOO00OO ,OO0000OOOO000000O )>=(10 ,4 )#line:234:return (major, minor) >= (10, 4)
        if O00O0O0O0OOO0O0O0 =='x86_64':#line:235:if arch == 'x86_64':
            return (O000000O0OOOO00OO ,OO0000OOOO000000O )>=(10 ,5 )#line:236:return (major, minor) >= (10, 5)
        if O00O0O0O0OOO0O0O0 in O0000O00O00OO0O00 :#line:237:if arch in groups:
            for OOO00OO00OO00OO0O in O0000O00O00OO0O00 [O00O0O0O0OOO0O0O0 ]:#line:238:for garch in groups[arch]:
                if _OOO0OOO0O0OO0O000 (O000000O0OOOO00OO ,OO0000OOOO000000O ,OOO00OO00OO00OO0O ):#line:239:if _supports_arch(major, minor, garch):
                    return True #line:240:return True
        return False #line:241:return False
    O0000O00O00OO0O00 =OrderedDict ([("fat",("i386","ppc")),("intel",("x86_64","i386")),("fat64",("x86_64","ppc64")),("fat32",("x86_64","i386","ppc")),])#line:248:])  # type: Dict[str, Tuple[str, ...]]
    if _OOO0OOO0O0OO0O000 (O0OO0OOOOOOOOOO0O ,O000OO0O0000O0OO0 ,O0O00OOO00O0O0O0O ):#line:250:if _supports_arch(major, minor, machine):
        O0OO000O000OOOO00 .append (O0O00OOO00O0O0O0O )#line:251:arches.append(machine)
    for O00O0000000000O00 in O0000O00O00OO0O00 :#line:253:for garch in groups:
        if O0O00OOO00O0O0O0O in O0000O00O00OO0O00 [O00O0000000000O00 ]and _OOO0OOO0O0OO0O000 (O0OO0OOOOOOOOOO0O ,O000OO0O0000O0OO0 ,O00O0000000000O00 ):#line:254:if machine in groups[garch] and _supports_arch(major, minor, garch):
            O0OO000O000OOOO00 .append (O00O0000000000O00 )#line:255:arches.append(garch)
    O0OO000O000OOOO00 .append ('universal')#line:257:arches.append('universal')
    return O0OO000O000OOOO00 #line:259:return arches
def get_all_minor_versions_as_strings (OO000OOOOO000OOO0 ):#line:262:def get_all_minor_versions_as_strings(version_info):
    OOOOOO0O00000O0O0 =[]#line:264:versions = []
    O000OOOO0O0OO00OO =OO000OOOOO000OOO0 [:-1 ]#line:265:major = version_info[:-1]
    for O0000OOO00000O0O0 in range (OO000OOOOO000OOO0 [-1 ],-1 ,-1 ):#line:267:for minor in range(version_info[-1], -1, -1):
        OOOOOO0O00000O0O0 .append (''.join (map (str ,O000OOOO0O0OO00OO +(O0000OOO00000O0O0 ,))))#line:268:versions.append(''.join(map(str, major + (minor,))))
    return OOOOOO0O00000O0O0 #line:269:return versions
def get_supported (versions =None ,noarch =False ,platform =None ,impl =None ,abi =None ):#line:278:):
    ""#line:291:"""
    OOO000OOO00O0OO00 =[]#line:292:supported = []
    if versions is None :#line:295:if versions is None:
        O000000O0OOOOO0O0 =get_impl_version_info ()#line:296:version_info = get_impl_version_info()
        versions =get_all_minor_versions_as_strings (O000000O0OOOOO0O0 )#line:297:versions = get_all_minor_versions_as_strings(version_info)
    impl =impl or get_abbr_impl ()#line:299:impl = impl or get_abbr_impl()
    OOOO000O00000000O =[]#line:301:abis = []  # type: List[str]
    abi =abi or get_abi_tag ()#line:303:abi = abi or get_abi_tag()
    if abi :#line:304:if abi:
        OOOO000O00000000O [0 :0 ]=[abi ]#line:305:abis[0:0] = [abi]
    O00O00O0O0O00O0OO =set ()#line:307:abi3s = set()
    for O00OOO00O0OOO000O in get_extension_suffixes ():#line:308:for suffix in get_extension_suffixes():
        if O00OOO00O0OOO000O .startswith ('.abi'):#line:309:if suffix.startswith('.abi'):
            O00O00O0O0O00O0OO .add (O00OOO00O0OOO000O .split ('.',2 )[1 ])#line:310:abi3s.add(suffix.split('.', 2)[1])
    OOOO000O00000000O .extend (sorted (list (O00O00O0O0O00O0OO )))#line:312:abis.extend(sorted(list(abi3s)))
    OOOO000O00000000O .append ('none')#line:314:abis.append('none')
    if not noarch :#line:316:if not noarch:
        OO0O000000OO0OO0O =platform or get_platform ()#line:317:arch = platform or get_platform()
        OOOO0O0OOOOOO00O0 ,OOO00O00O0O0O000O ,OOO00OOO00O000000 =OO0O000000OO0OO0O .partition ('_')#line:318:arch_prefix, arch_sep, arch_suffix = arch.partition('_')
        if OO0O000000OO0OO0O .startswith ('macosx'):#line:319:if arch.startswith('macosx'):
            OO0O000OOO00OO000 =_O00OO0O00OOOOO0OO .match (OO0O000000OO0OO0O )#line:321:match = _osx_arch_pat.match(arch)
            if OO0O000OOO00OO000 :#line:322:if match:
                O0O00O00OOOOOO000 ,O00O0000O000OO0O0 ,O0OO0O0O0000O0OO0 ,O0000OO0OO0O000OO =OO0O000OOO00OO000 .groups ()#line:323:name, major, minor, actual_arch = match.groups()
                O00O0O00O00OOO00O ='{}_{}_%i_%s'.format (O0O00O00OOOOOO000 ,O00O0000O000OO0O0 )#line:324:tpl = '{}_{}_%i_%s'.format(name, major)
                OO00OOOO0O00OO0OO =[]#line:325:arches = []
                for O0O0000OOO0OOOO00 in reversed (range (int (O0OO0O0O0000O0OO0 )+1 )):#line:326:for m in reversed(range(int(minor) + 1)):
                    for O0OO0O0OO00OO00O0 in get_darwin_arches (int (O00O0000O000OO0O0 ),O0O0000OOO0OOOO00 ,O0000OO0OO0O000OO ):#line:327:for a in get_darwin_arches(int(major), m, actual_arch):
                        OO00OOOO0O00OO0OO .append (O00O0O00O00OOO00O %(O0O0000OOO0OOOO00 ,O0OO0O0OO00OO00O0 ))#line:328:arches.append(tpl % (m, a))
            else :#line:329:else:
                OO00OOOO0O00OO0OO =[OO0O000000OO0OO0O ]#line:331:arches = [arch]
        elif OOOO0O0OOOOOO00O0 =='manylinux2010':#line:332:elif arch_prefix == 'manylinux2010':
            OO00OOOO0O00OO0OO =[OO0O000000OO0OO0O ,'manylinux1'+OOO00O00O0O0O000O +OOO00OOO00O000000 ]#line:337:arches = [arch, 'manylinux1' + arch_sep + arch_suffix]
        elif platform is None :#line:338:elif platform is None:
            OO00OOOO0O00OO0OO =[]#line:339:arches = []
            if is_manylinux2010_compatible ():#line:340:if is_manylinux2010_compatible():
                OO00OOOO0O00OO0OO .append ('manylinux2010'+OOO00O00O0O0O000O +OOO00OOO00O000000 )#line:341:arches.append('manylinux2010' + arch_sep + arch_suffix)
            if is_manylinux1_compatible ():#line:342:if is_manylinux1_compatible():
                OO00OOOO0O00OO0OO .append ('manylinux1'+OOO00O00O0O0O000O +OOO00OOO00O000000 )#line:343:arches.append('manylinux1' + arch_sep + arch_suffix)
            OO00OOOO0O00OO0OO .append (OO0O000000OO0OO0O )#line:344:arches.append(arch)
        else :#line:345:else:
            OO00OOOO0O00OO0OO =[OO0O000000OO0OO0O ]#line:346:arches = [arch]
        for abi in OOOO000O00000000O :#line:349:for abi in abis:
            for OO0O000000OO0OO0O in OO00OOOO0O00OO0OO :#line:350:for arch in arches:
                OOO000OOO00O0OO00 .append (('%s%s'%(impl ,versions [0 ]),abi ,OO0O000000OO0OO0O ))#line:351:supported.append(('%s%s' % (impl, versions[0]), abi, arch))
        for OO0O0OO0O0000OO00 in versions [1 :]:#line:354:for version in versions[1:]:
            if OO0O0OO0O0000OO00 in {'31','30'}:#line:356:if version in {'31', '30'}:
                break #line:357:break
            for abi in O00O00O0O0O00O0OO :#line:358:for abi in abi3s:   # empty set if not Python 3
                for OO0O000000OO0OO0O in OO00OOOO0O00OO0OO :#line:359:for arch in arches:
                    OOO000OOO00O0OO00 .append (("%s%s"%(impl ,OO0O0OO0O0000OO00 ),abi ,OO0O000000OO0OO0O ))#line:360:supported.append(("%s%s" % (impl, version), abi, arch))
        for OO0O000000OO0OO0O in OO00OOOO0O00OO0OO :#line:363:for arch in arches:
            OOO000OOO00O0OO00 .append (('py%s'%(versions [0 ][0 ]),'none',OO0O000000OO0OO0O ))#line:364:supported.append(('py%s' % (versions[0][0]), 'none', arch))
    OOO000OOO00O0OO00 .append (('%s%s'%(impl ,versions [0 ]),'none','any'))#line:367:supported.append(('%s%s' % (impl, versions[0]), 'none', 'any'))
    OOO000OOO00O0OO00 .append (('%s%s'%(impl ,versions [0 ][0 ]),'none','any'))#line:370:supported.append(('%s%s' % (impl, versions[0][0]), 'none', 'any'))
    for O0OO00O00OO0000O0 ,OO0O0OO0O0000OO00 in enumerate (versions ):#line:373:for i, version in enumerate(versions):
        OOO000OOO00O0OO00 .append (('py%s'%(OO0O0OO0O0000OO00 ,),'none','any'))#line:374:supported.append(('py%s' % (version,), 'none', 'any'))
        if O0OO00O00OO0000O0 ==0 :#line:375:if i == 0:
            OOO000OOO00O0OO00 .append (('py%s'%(OO0O0OO0O0000OO00 [0 ]),'none','any'))#line:376:supported.append(('py%s' % (version[0]), 'none', 'any'))
    return OOO000OOO00O0OO00 #line:378:return supported
implementation_tag =get_impl_tag ()#line:381:implementation_tag = get_impl_tag()
